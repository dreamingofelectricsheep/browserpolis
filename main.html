<html>
<head><title>Browser Ville</title>
<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;

    void main(void) {
        gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
    }
</script>
<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 position;

	uniform mat4 model;
	uniform mat4 view;
    uniform mat4 projection;

    void main(void) {
        gl_Position =  projection * view * model * vec4(position, 1.0);
    }
</script>
<script type="text/javascript">
function mat4() {
	this.value = new Float32Array(16)
}

mat4.prototype = {
	identity: function() {
		for(var i = 0; i < 16; i++)
			this.value[i] = 0
		for(var i = 0; i < 16; i += 5)
			this.value[i] = 1
	},
	perspective: function(fovy, aspect, near, far) {
		var f = 1.0 / Math.tan(fovy / 2),
		nf = 1 / (near - far)

		this.identity()

		this.value[0] = f / aspect
		this.value[5] = f
		this.value[10] = (far + near) * nf
		this.value[11] = -1
		this.value[14] = (2 * far * near) * nf
		this.value[15] = 0	
	},
	translation: function(x, y, z) {
		this.identity()
		this.value[3] = x
		this.value[7] = y
		this.value[11] = z
	},
	rotation: function(x, y, z) {
		var c = Math.cos, s = Math.sin
		var val = [
			c(y)*c(z),
			-c(x)*s(z)+s(x)*s(y)*c(z),
			s(x)*s(z)+c(x)*s(y)*c(z),
			0,
			c(y)*s(z),
			c(x)*c(z)+s(x)*s(y)*s(z),
			-s(x)*c(z)+c(x)*s(y)*s(z),
			0,
			-s(y), s(x)*c(y), c(x)*c(y), 0,
			0, 0, 0, 1]
			
		for(var i in val) this.value[i] = val[i]
	},
	mul: function(mat) {
		

	}	
}

function engine(parent) {
	this.canvas = document.createElement('canvas')
	this.canvas.width = window.innerWidth
	this.canvas.height = window.innerHeight

	this.gl = this.canvas.getContext('experimental-webgl')
	if(this.gl == undefined)
		alert("No webgl!") 

	this.gl.enable(this.gl.DEPTH_TEST)
	this.gl.clearColor(0.0, 0.0, 0.0, 1.0)

	parent.appendChild(this.canvas)
}

engine.prototype = {
	draw: function() {
		this.gl.viewport(0, 0, this.canvas.width, this.canvas.height)
		this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT)

		for(var i in this.scene.objects) {

			var mat = new mat4()
			mat.identity()
			var rot = new mat4()
			var d = (new Date().getTime() % 5000) / 5000 * Math.PI * 2
			rot.rotation(0, 0, d)
			var o = this.scene.objects[i]
			var prog = o.program

			prog.uniform.model.set(rot)
			prog.uniform.view.set(mat)
			prog.uniform.projection.set(this.scene.camera.projection)

			o.draw(prog.attrib.position)
		}

		var that = this
		requestAnimationFrame(function() { that.draw() })
	},
	vertex_shader: function(plaintext) {
		return new shader(this.gl, this.gl.VERTEX_SHADER, plaintext)
	},
	fragment_shader: function(plaintext) {
		return new shader(this.gl, this.gl.FRAGMENT_SHADER, plaintext)
	},
	program: function(vertex, fragment) {
		return new program(this.gl, vertex, fragment)
	},
	buffer: function() {
		return new buffer(this.gl)
	}
}

function entity() {
	this.position = [0, 0, 0]
	this.rotation = [0, 0, 0]
	this.scale = [0, 0, 0]
}

function shader(gl, type, plaintext) {
	this.shader = gl.createShader(type)
	this.type = type
	gl.shaderSource(this.shader, plaintext)
	gl.compileShader(this.shader)

	if (!gl.getShaderParameter(this.shader, gl.COMPILE_STATUS)) {
		alert(gl.getShaderInfoLog(this.shader))
	}
}

function program(gl, vertex, fragment) {
	this.program = gl.createProgram()
	gl.attachShader(this.program, vertex.shader)
	gl.attachShader(this.program, fragment.shader)
	gl.linkProgram(this.program)

	if(!gl.getProgramParameter(this.program, gl.LINK_STATUS))
		alert("Error during shader init.")

	this.uniform = {}
	this.attrib = {}

	gl.useProgram(this.program)

	var t, i = 0
	while(t = gl.getActiveUniform(this.program, i++)) {
		this.uniform[t.name] = {
			uniform: gl.getUniformLocation(this.program, t.name),
			set: function(mat) { gl.uniformMatrix4fv(this.uniform, false, mat.value) }
		}
	}

	i = 0
	while(t = gl.getActiveAttrib(this.program, i++)) {
		this.attrib[t.name] = {
			attrib: gl.getAttribLocation(this.program, t.name)
		}
		gl.enableVertexAttribArray(this.attrib[t.name].attrib)
	}
}

function buffer(gl, data) {
	this.buffer = gl.createBuffer()
	this.gl = gl
	this.items = 0
	this.subitems = 0

}

buffer.prototype = {
	bind: function () {
		this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer)
	},
	data: function(d) {
		this.bind()
		this.items = d.length
		this.subitems = d[0].length
		var arr = []
		for(var i in d) arr = arr.concat(d[i])
		arr = new Float32Array(arr)

		this.gl.bufferData(this.gl.ARRAY_BUFFER, arr, this.gl.STATIC_DRAW)
	},
	draw: function(attrib) {
		this.bind()
		this.gl.vertexAttribPointer(attrib.attrib, this.subitems, this.gl.FLOAT, false, 0, 0)
		this.gl.drawArrays(this.gl.TRIANGLES, 0, this.items)
	}
}

window.onload = function() {
var body = document.getElementsByTagName('body')[0]

var eng = new engine(body)

var vertext = document.getElementById('shader-vs').innerHTML
var fragtext = document.getElementById('shader-fs').innerHTML

var vs = eng.vertex_shader(vertext)
var fs = eng.fragment_shader(fragtext)

var prog = eng.program(vs, fs)

var square = eng.buffer()
square.data([
	[0.0,  1.0,  -1.0],
	[-1.0,  -1.0,  -1.0],
	[1.0, -1.0,  -1.0]])
square.program = prog


var perspective = new mat4()
perspective.perspective(90, window.innerWidth/window.innerHeight, 0.1, 1000)

eng.scene = {
	camera: {
		projection: perspective
	},
	objects: [square]
}

eng.draw()

}
</script>
<style type="text/css">
body {
	margin: 0;
}
canvas {
	width: 100%;
	height: 100%;
}
</style>
</head>
<body>
</body>
</html>
